#!/usr/bin/env python

"""
Copyright Netherlands eScience Center

Function        : Quantify oceanic meridional energy transport (ORAS4)
Author          : Yang Liu
Date            : 2017.8.30
Last Update     : 2017.9.1
Description     : The code aims to calculate the oceanic meridional energy
                  transport based on oceanic reanalysis dataset ORAS4
                  from ECMWF. The complete computaiton is accomplished on model
                  level (original ORCA1_z42 grid). The procedure is generic and
                  is able to adapt any atmospheric reanalysis datasets, with some changes.

Return Value    : NetCFD4 data file
Dependencies    : os, time, numpy, netCDF4, sys, matplotlib, logging
variables       : Potential Temperature                     Theta
                  Sea Water Density                         rho
                  Specific Heat Capacity of Sea Water       cp
                  Zonal Current Velocity                    u
                  Meridional Current Velocity               v
                  Land-Sea Mask
                  Meridional Grid Spacing Scale Factors     e1

Caveat!!        : The full dataset is from 1958. However, a quality report from
                  Magdalena from ECMWF indicates the quality of data for the first
                  two decades are very poor. Hence we use the data from 1979. which
                  is the start of satellite era.
"""
import numpy as np
import seaborn as sns
#import scipy as sp
import time as tttt
from netCDF4 import Dataset,num2date
import os
import platform
import sys
import logging
import matplotlib
# generate images without having a window appear
#matplotlib.use('Agg')
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap, cm
import cartopy.crs as ccrs
import iris
import iris.plot as iplt
import iris.quickplot as qplt

##########################################################################
###########################   Units vacabulory   #########################
# cpT:  [J / kg K] * [K]     = [J / kg]
# v*rho cpT dxdz = [m/s] * [J / kg] * [kg/m3] * m * m = [J / s] = [Wat]

# gz in [m2 / s2] = [ kg m2 / kg s2 ] = [J / kg]
##########################################################################

# print the system structure and the path of the kernal
print platform.architecture()
print os.path

# switch on the seaborn effect
sns.set()

# calculate the time for the code execution
start_time = tttt.time()

# Redirect all the console output to a file
#sys.stdout = open('F:\DataBase\ORAS4\console.out','w')
#sys.stdout = open('/project/Reanalysis/ORAS4/console_E.out','w')

# logging level 'DEBUG' 'INFO' 'WARNING' 'ERROR' 'CRITICAL'
#logging.basicConfig(filename = 'F:\DataBase\ORAS4\history.log', filemode = 'w',level = logging.DEBUG,format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
#logging.basicConfig(filename = '/project/Reanalysis/ORAS4/history_E.log',
#                    filemode = 'w', level = logging.DEBUG,
#                    format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# define the constant:
constant ={'g' : 9.80616,      # gravititional acceleration [m / s2]
           'R' : 6371009,      # radius of the earth [m]
           'cp': 3987,         # heat capacity of air [J/(Kg*K)]
           'rho': 1027,        # sea water density [K/m3]
            }

################################   Input zone  ######################################
# specify data path
datapath = 'F:\DataBase\ORAS\ORAS4\Monthly\model'
#datapath = '/project/Reanalysis/ORAS4'
# time of the data, which concerns with the name of input
# starting time (year)
start_year = 1979
# Ending time, if only for 1 year, then it should be the same as starting year
end_year = 1979
# specify output path for the netCDF4 file
output_path_fig = 'C:\Yang\PhD\Computation and Modeling\Blue Action\OMET\ORAS4'
#output_path = '/project/Reanalysis/ERA_Interim/Subdaily/Model'
# benchmark datasets for basic dimensions
#benchmark_path = 'F:\DataBase\ORAS\ORAS4\Monthly\model\\thetao_oras4_1m_1979_grid_T.nc'
#benchmark = Dataset(benchmark_path)
####################################################################################

def var_key(datapath, year):
    # get the path to each datasets
    print "Start retrieving datasets"
    #logging.info("Start retrieving variables theta,s,u,v for from %d (y)" % (year)
    datapath_theta = datapath + os.sep + 'theta' + os.sep + 'thetao_oras4_1m_%d_grid_T.nc' % (year)
    datapath_s = datapath + os.sep + 's' + os.sep + 'so_oras4_1m_%d_grid_T.nc' % (year)
    datapath_u = datapath + os.sep + 'u' + os.sep + 'uo_oras4_1m_%d_grid_U.nc' % (year)
    datapath_v = datapath + os.sep + 'v' + os.sep + 'vo_oras4_1m_%d_grid_V.nc' % (year)

    # get the variable keys
    theta_key = Dataset(datapath_theta)
    s_key = Dataset(datapath_s)
    u_key = Dataset(datapath_u)
    v_key = Dataset(datapath_v)

    print "Retrieving datasets for the year %d successfully!" % (year)
    #logging.info("Retrieving variables for the year %d successfully!" % (year))
    return theta_key, s_key, u_key, v_key

def var_coordinate(datapath):
    print "Start retrieving the datasets of ORCA1 coordinate and mask info"
    #logging.info('Start retrieving the datasets of ORCA1 coordinate and mask info')
    # get the variable keys
    mesh_mask_key = Dataset(datapath+ os.sep + 'mesh_mask.nc')
    #grid_T_key = Dataset(datapath+ os.sep + 'coordinates_grid_T.nc')
    #grid_U_key = Dataset(datapath+ os.sep + 'coordinates_grid_U.nc')
    #grid_V_key = Dataset(datapath+ os.sep + 'coordinates_grid_V.nc')
    #extract variables
    # lat-lon-depth coordinate info
    nav_lat = mesh_mask_key.variables['nav_lat'][:]
    nav_lon = mesh_mask_key.variables['nav_lon'][:]
    nav_lev = mesh_mask_key.variables['nav_lev'][:]
    # land-sea mask
    tmask = mesh_mask_key.variables['tmask'][0,:,:,:]
    #umask = mesh_mask_key.variables['umask'][0,:,:,:]
    #vmask = mesh_mask_key.variables['vmask'][0,:,:,:]
    # grid spacing scale factors (zonal)
    e1t = mesh_mask_key.variables['e1t'][0,:,:]
    e1u = mesh_mask_key.variables['e1u'][0,:,:]
    e1v = mesh_mask_key.variables['e1v'][0,:,:]
    # comparison between variables
    #lat_grid_T = grid_T_key.variables['lat'][:]
    #lon_grid_T = grid_T_key.variables['lon'][:]
    #tmask_grid_T = grid_T_key.variables['tmask'][:]

    #lat_grid_U = grid_U_key.variables['lat'][:]
    #lon_grid_U = grid_U_key.variables['lon'][:]
    #umask_grid_U = grid_U_key.variables['umask'][:]

    #lat_grid_V = grid_V_key.variables['lat'][:]
    #lon_grid_V = grid_V_key.variables['lon'][:]
    #vmask_grid_V = grid_V_key.variables['vmask'][:]

    #Comparison
    #print 'The tmask file from mesh_mask.nc and the grid T are the same %s' % \
    #       np.array_equal(tmask,tmask_grid_T)

    return nav_lat, nav_lon, nav_lev, tmask, e1t


def meridional_energy_transport(theta_key, s_key, u_key, v_key):
    # extract variables
    print "Start extracting variables for the quantification of meridional energy transport."
    theta = theta_key.variables['thetao'][:] # the unit of theta is Celsius!
    #u = u_key.variables['uo'][:]
    v = v_key.variables['vo'][:]
    print 'Extracting variables successfully!'
    #logging.info("Extracting variables successfully!")
    # calculate heat flux at each grid point
    Internal_E_flux = np.zeros((len(index_month),level,jj,ji),dtype=float)
    for i in index_month:
        for j in np.arange(level):
            if j == 0:
                Internal_E_flux[i,j,:,:] = constant['rho'] * constant['cp'] * v[i,j,:,:] *\
                                      (theta[i,j,:,:] + 273.15) * e1t * nav_lev[j]
            else:
                Internal_E_flux[i,j,:,:] = constant['rho'] * constant['cp'] * v[i,j,:,:] *\
                                      (theta[i,j,:,:] + 273.15) * e1t *(nav_lev[j]-nav_lev[j-1])
    # take the vertical integral
    Internal_E_int = np.zeros((len(index_month),jj,ji))
    Internal_E_int = np.sum(Internal_E_flux,1)/1e+12
    print '*****************************************************************************'
    print "**** Computation of meridional energy transport in the ocean is finished ****"
    print "************         The result is in tera-watt (1E+12)          ************"
    print '*****************************************************************************'
    return Internal_E_int

def visualization_model_basedmap(E,year):
    fig1 = plt.figure()
    # setup global Equidistant Cylindrical Projection
    m = Basemap(projection='cyl',llcrnrlat=-90,urcrnrlat=90,\
               llcrnrlon=-180,urcrnrlon=180,lon_0=0,lat_0=0,resolution='l')
    # draw coastlines
    m.drawcoastlines()
    # draw parallels and meridians
    m.drawparallels(np.arange(-90,91,30),labels=[1,1,0,0],fontsize = 8)
    m.drawmeridians(np.arange(-180,181,60),labels=[0,0,0,1],fontsize = 8)
    # x,y coordinate - lon, lat
    #xx, yy = np.meshgrid(nav_lon,nav_lat)
    XX, YY = m(nav_lon, nav_lat)
    # define color range for the contourf
    color = np.linspace(-2,2,21)
    # !!!!!take care about the coordinate of contourf(Longitude, Latitude, data(Lat,Lon))
    cs = m.contourf(XX,YY,E,color,cmap='coolwarm')
    # add color bar
    cbar = m.colorbar(cs,location="bottom",size='4%',pad="8%",format='%.1f')
    cbar.ax.tick_params(labelsize=8)
    #cbar.set_ticks(np.arange(-1,1.1,0.2))
    #cbar.set_ticklabels(np.arange(-1,1.1,0.2))
    cbar.set_label('TW',fontsize = 8)
    plt.title('Meridional Energy Transport in the Ocean from ORAS4 %d' % (year),fontsize = 9, y=1.05)
    plt.show()
    fig1.savefig(output_path_fig + os.sep + "OMET_ORAS4_%d.jpeg" % (year),dpi=500)

def regrid_visualization(E,nav_lat,nav_lon,mask):
    # mask E for visualization
    E_mask = np.ma.masked_values(E,mask)
    # define the cube for the use of iris package
    latitude = iris.coords.AuxCoord(nav_lat,standard_name='latitude',units='degrees')
    longitude = iris.coords.AuxCoord(nav_lon,standard_name='longitude',units='degrees')
    cube_E = iris.cube.Cube(E_mask/1000,long_name='Oceanic Meridional Energy Transport',
                            var_name='OMET',units='PW',aux_coords_and_dims=[(latitude,(0,1)),(longitude,(0,1))])
    print cube_E
    # regridding plotting through Iris
    iris.FUTURE.netcdf_promote = True
    projections = {}
    projections['PlateCarree'] = ccrs.PlateCarree()
    pcarree = projections['PlateCarree']
    # Transform cube to target projection
    cube_regrid, extent = iris.analysis.cartography.project(cube_E, pcarree, nx=360, ny=180)
    print cube_regrid
    fig2 = plt.figure()
    fig2.suptitle('ORCA1 Data Projected to PlateCarree')
    # Set up axes and title
    ax = plt.subplot(projection=ccrs.PlateCarree())
    # Set limits
    ax.set_global()
    # plot with Iris quickplot pcolormesh
    qplt.pcolormesh(cube_regrid,cmap='coolwarm')
    # Draw coastlines
    ax.coastlines()
    iplt.show()
    fig2.savefig(output_path_fig + os.sep + 'OMET_ORAS4.jpg',dpi = 500)

    # extract the interpolated values from cube
    E_interpolation = cube_regrid.data

    return E_interpolation

def zonal_int_plot(E_point_interpolation):
    # take the zonal means
    E_zonal_int = np.mean(E_point_interpolation,1)
    fig3 = plt.figure()
    plt.plot(np.arange(-90,91,1),E_zonal_int)
    plt.show()

    return E_zonal_int


if __name__=="__main__":
    # create the year index
    period = np.arange(start_year,end_year+1,1)
    index_month = np.arange(12)
    # ORCA1_z42 infor (Madec and Imbard 1996)
    ji = 362
    jj = 292
    level = 42
    # extract the mesh_mask and coordinate information
    nav_lat, nav_lon, nav_lev, tmask, e1t = var_coordinate(datapath)
    #create a data pool to save the OMET for each year and month
    OMET_E_pool_point = np.zeros((len(period),12,jj,ji),dtype = float)
    #OMET_E_pool_zonal_int = np.zeros((len(period),12,jj,ji),dtype = float)
    # loop for calculation
    for i in period:
        # get the key of each variable
        theta_key, s_key, u_key, v_key = var_key(datapath, i)
        # calculate the meridional energy transport in the ocean
        E_point = meridional_energy_transport(theta_key, s_key, u_key, v_key)
        OMET_E_pool_point[i-1979,:,:,:] = E_point
        # take the mean value over the entire year for basemap
        E_point_mean = np.mean(E_point,0)
        del E_point
        # visualization
        # The basemap module doesn't work since the data is not monotonic in any direction
        #visualization_model_basedmap(E_point_mean,i)
        # Tri-Polar Grid Projected plotting through Iris and Cartopy
        E_point_interpolation = regrid_visualization(E_point_mean,nav_lat,nav_lon,tmask[0,:,:])
        E_zonal_int = zonal_int_plot(E_point_interpolation)


print ("--- %s minutes ---" % ((tttt.time() - start_time)/60))
