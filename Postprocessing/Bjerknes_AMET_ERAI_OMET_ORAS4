#!/usr/bin/env python
"""
Copyright Netherlands eScience Center
Function        : Bjerknes Compensation between AMET and OMET
Author          : Yang Liu
Date            : 2017.10.14
Last Update     : 2017.10.19
Description     : The code aims to study the Bjerknes compensation between atmosphere
                  and ocean. The atmospheric meridional energy transport is calculated
                  from reanalysis data ERA-Interim. The oceanic meridional energy
                  transport is calculated from ORAS4.
Return Value    : NetCFD4 data file
Dependencies    : os, time, numpy, netCDF4, sys, matplotlib, logging
variables       : Atmospheric Meridional Energy Transport   ERA-Interim
                  Oceanic Meridional Energy Transport       ORAS4
Caveat!!        : The full dataset of ORAS4 is from 1958. However, a quality report from
                  Magdalena from ECMWF indicates the quality of data for the first
                  two decades are very poor. Hence we use the data from 1979. which
                  is the start of satellite era.
"""
import numpy as np
import seaborn as sns
#import scipy as sp
import time as tttt
from netCDF4 import Dataset,num2date
import os
import platform
import sys
import logging
import matplotlib
# generate images without having a window appear
#matplotlib.use('Agg')
import matplotlib.pyplot as plt
# univariate spline fitting (interpolation)
from scipy.interpolate import InterpolatedUnivariateSpline
from mpl_toolkits.basemap import Basemap, cm
import cartopy.crs as ccrs
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
import iris
import iris.plot as iplt
import iris.quickplot as qplt

# print the system structure and the path of the kernal
print platform.architecture()
print os.path

# switch on the seaborn effect
sns.set()

# calculate the time for the code execution
start_time = tttt.time()

################################   Input zone  ######################################
# specify data path
datapath_AMET = 'F:\DataBase\HPC_out\ERAI\postprocessing'
datapath_OMET = 'F:\DataBase\HPC_out\ORAS4\postprocessing'
# specify output path for the netCDF4 file
output_path = 'F:\DataBase\HPC_out\Bjerknes_ERAI_ORAS4'
# index of latitude for insteret
# 60N
lat_OMET = 233
lat_AMET = 40
# mask path
mask_path = 'F:\DataBase\ORAS\ORAS4\Monthly\Model'
####################################################################################
print '*******************************************************************'
print '*********************** extract variables *************************'
print '*******************************************************************'
dataset_AMET = Dataset(datapath_AMET + os.sep + 'model_daily_075_1979_2016_E_zonal_int.nc')
dataset_OMET = Dataset(datapath_OMET + os.sep + 'oras4_model_monthly_orca1_1958_2014_E_zonal_int.nc')

for k in dataset_OMET.variables:
    print dataset_OMET.variables['%s' % (k)]
for l in dataset_AMET.variables:
    print dataset_AMET.variables['%s' % (l)]

# from 1979 to 2014
AMET = dataset_AMET.variables['E'][:-2,:,:]/1000 # from Tera Watt to Peta Watt
OMET = dataset_OMET.variables['E'][21:,:,:]/1000 # from Tera Watt to Peta Watt # start from 1979

year = dataset_OMET.variables['year'][21:]    # from 1979 to 2014
month = dataset_OMET.variables['month'][:]
latitude_OMET = dataset_OMET.variables['latitude_aux'][:]
latitude_AMET = dataset_AMET.variables['latitude'][:]

print '*******************************************************************'
print '*************************** whitening *****************************'
print '*******************************************************************'
month_ind = np.arange(12)
year_ind = np.arange(len(year))
seansonal_cycle_AMET = np.mean(AMET,axis=0)
seansonal_cycle_OMET = np.mean(OMET,axis=0)
AMET_white = np.zeros(AMET.shape,dtype=float)
OMET_white = np.zeros(OMET.shape,dtype=float)
for i in year_ind:
    for j in month_ind:
        AMET_white[i,j,:] = AMET[i,j,:] - seansonal_cycle_AMET[j,:]
        OMET_white[i,j,:] = OMET[i,j,:] - seansonal_cycle_OMET[j,:]

print '*******************************************************************'
print '****************** prepare variables for plot *********************'
print '*******************************************************************'
# annual mean of AMET and OMET at different latitudes
AMET_mean = np.mean(np.mean(AMET,0),0)
OMET_mean = np.mean(np.mean(OMET,0),0)
# Using radial basis functions for smoothing/interpolation
OMET_mean_interpolate = np.zeros(AMET_mean.shape,dtype=float)
ius = InterpolatedUnivariateSpline(latitude_OMET[130:], OMET_mean[130:])
OMET_mean_interpolate = ius(latitude_AMET)

# dataset with seasonal cycle - time series
AMET_series = AMET.reshape(len(year)*len(month),len(latitude_AMET))
OMET_series = OMET.reshape(len(year)*len(month),len(latitude_OMET))
# dataset without seasonal cycle - time series
AMET_white_series = AMET_white.reshape(len(year)*len(month),len(latitude_AMET))
OMET_white_series = OMET_white.reshape(len(year)*len(month),len(latitude_OMET))

# interpolate OMET on the latitude of AMET through univariate spline fitting
# Using radial basis functions for smoothing/interpolation
OMET_interpolate = np.zeros((len(year),len(month),len(latitude_AMET)),dtype=float)
for i in year_ind:
    for j in month_ind:
        ius = InterpolatedUnivariateSpline(latitude_OMET[130:], OMET[i,j,130:])
        OMET_interpolate[i,j,:] = ius(latitude_AMET)

# remove the seasonal cycle after the interpolation of OMET
seansonal_cycle_OMET_interpolate = np.mean(OMET_interpolate,axis=0)
OMET_interpolate_white = np.zeros(OMET_interpolate.shape,dtype=float)
for i in year_ind:
    for j in month_ind:
        OMET_interpolate_white[i,j,:] = OMET_interpolate[i,j,:] - seansonal_cycle_OMET_interpolate[j,:]

print '*******************************************************************'
print '*************************** x-y plots *****************************'
print '*******************************************************************'
fig0 = plt.figure()
plt.plot(latitude_AMET,AMET_mean,'r-',label='ERA-Interim')
plt.plot(latitude_OMET[130:],OMET_mean[130:],'b-',label='ORAS4')
plt.plot(latitude_AMET,AMET_mean+OMET_mean_interpolate,'g-',label='Total')
plt.title('Meridional Energy Transport at 60 N (1979-2014)')
#plt.legend()
#fig1.set_size_inches(5, 5)
plt.xlabel("Latitude")
plt.xticks(np.linspace(30, 90, 10))
#plt.xticks(rotation=60)
plt.ylabel("Meridional Energy Transport (PW)")
plt.show()
fig0.savefig(output_path + os.sep + 'AMET_OMET_annual_mean_1979_2014.jpg', dpi = 500)

print '*******************************************************************'
print '*********************** time series plots *************************'
print '*******************************************************************'
# time series plot of meridional energy transport at 60N
fig1 = plt.figure()
plt.plot(index,AMET_series[:,lat_AMET],'r-',label='ERA-Interim')
plt.plot(index,OMET_series[:,lat_OMET],'b-',label='ORAS4')
plt.title('Meridional Energy Transport at 60 N (1979-2014)')
plt.legend()
fig1.set_size_inches(14, 5)
plt.xlabel("Time")
plt.xticks(np.linspace(0, 432, 37), year)
plt.xticks(rotation=60)
plt.ylabel("Meridional Energy Transport (PW)")
plt.show()
fig1.savefig(output_path + os.sep + 'AMET_OMET_60N_total_time_series_1979_2014.jpg', dpi = 500)

fig2 = plt.figure()
plt.plot(index,AMET_white_series[:,lat_AMET],'r-',label='ERA-Interim')
plt.plot(index,OMET_white_series[:,lat_OMET],'b-',label='ORAS4')
plt.title('Meridional Energy Transport Anomalies at 60 N (1979-2014)')
plt.legend()
fig2.set_size_inches(14, 5)
plt.xlabel("Time")
plt.xticks(np.linspace(0, 432, 37), year)
plt.xticks(rotation=60)
plt.ylabel("Meridional Energy Transport (PW)")
plt.show()
fig2.savefig(output_path + os.sep + 'AMET_OMET_60N_anomaly_time_series_1979_2014.jpg', dpi = 500)

###################################  Atmosphere  ###################################
# land-sea mask
# surface mask for v grid
vmask = dataset_mask.variables['vmask'][0,0,:,:]

print '*******************************************************************'
print '*********************** Regression plots **************************'
print '*******************************************************************'
#Regression
# create an array to store the correlation coefficient
slope = np.zeros((lat_AMET+1,len(lon)),dtype = float)
r_value = np.zeros((lat_AMET+1,len(lon)),dtype = float)
p_value = np.zeros((lat_AMET+1,len(lon)),dtype = float)
for i in np.arange(lat_AMET+1):
    for j in np.arange(len(lon)):
        # return value: slope, intercept, r_value, p_value, stderr
        slope[i,j],_,r_value[i,j],p_value[i,j],_ = stats.linregress(x,y[:,i,j])
#Regression with time lag
